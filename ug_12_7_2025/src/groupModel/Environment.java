/*
Copyright 2025 by Jeffrey C. Schank
Licensed under the Academic Free License version 3.0
See https://opensource.org/licenses/AFL-3.0 for more information
 */
package groupModel;
/**
 * Simulation environment for ultimatum game evolutionary simulations.
 * To run this simulation in graphic mode requires MASON (19), MASONplus10, and jfreechart-1.0.17.jar 
 * 
 */

import sim.util.Bag;
import sim.util.distribution.Uniform;
import spaces.Spaces;
import sweep.SimStateSweep;



public class Environment extends SimStateSweep {
	//Population variables
	public int n = 10000; //number of agents at the beginning of a simulation
	public int maxN = 10000;//the maximum number of agents in a population
	public int groups = 500;//Initial number of groups
	public int maxGroupSize = 40;//maximum number of agents in a group at which the group randomly splits
	public int minGroupSize = 2; //groups with agents less than this, disperse to other patches
	public int groupRadius = 1;//when groups fission, this is the radius in which the offspring group can be randomly placed
	public double globalGroupDispersion = 0.1;//The probability that a group will fission and the fission group move to any random
	//empty location in space--value set as an example to generate distribution in Engle 2011

	//reproduction variables
	public double mutationRate = 0.01;//rate of mutations in offers
	public boolean ibi = true; //true if an ibiTau is requried
	public double ibiTau = 150; //minimum steps between reproductive events
	public double io = 750; //minimum resources required to reproduce;
	public double baseResourceEndowment = 5; //base resource endowment for auto calculation. This is the maximum quantity of resources
	//each agent can expect to achieve if there are no rejections and endowment
	public double percentBaseResourceEndowment = 1.0;
	public boolean carryOver = true;

	//age variables
	public double averageAge = 600;//mean age of agents
	public double age_ibiTau_multiplier = 4.0;//average age is ibiTau * age_ibiTau_multiplier
	public double sdAge = 0.1;//standard deviation in age, variation generated by calling
	//random.nextGaussian()

	//Resource variables
	public double resourceEndowment = 10;//resource endowed to dictators
	public double resourceEndowmentSD = 0.5;//10% of the resource Endowment
	public double reSD; //= resourceEndowment * resourceEndowmentSD;
	//variation in resource endowments are created using
	//random.nextGaussian()
	
	public double resourceEndowmentSuccessRate = 0.5;//success rate at receiving an endowment
	//game parameters
	public int recipients = 1;//maximum number of recipients, or target number of recipients
	public int proposers = 1; //the number of proposers in the game.  for the n-person ultimatum game n = recipients + proposers
	public int n_intervals = 10; //even number
	//--value set as an example to generate distribution in Engle 2011
	public boolean sex = true;//sexual reproduction
	public boolean ugOfferZero = false;//intitializes all offers and acceptance values to 0

	//Dispersal variables
	public double dispersalRate = 0.1;//rate of dispersay when born--value set as an example to generate distribution in Engle 2011
	public int dispersalRadius = 1;//if dispersal occurs at birth, then this is the radius of dispersal	

	//other variables 
	public Experimenter experimenter;//agent that runs and collects data from simulations
	public double [] offerArray;//values of offer mutations
	public int offerIntervals;//number of intervals
	public boolean dynamicColorGroup = false;//if true, groups are dynamically colored on birth, death, dispersion
	public int samplingInterFactor = 10; //multiplied by average age
	public int generations = 1000;//number of generations the simuation run * average age
	public int burinGenerations = 900;//number of burnin generations * average age
	public int rejectionSampleSize = 1000;// sample size for rejection observations
	public Uniform uniform = null;
	public TruncNormal tnormal = null;




	/*
	 * Getter and setter methods begin
	 */


	public int getN() {
		return n;
	}


	public void setN(int n) {
		this.n = n;
	}


	public int getMaxN() {
		return maxN;
	}


	public void setMaxN(int maxN) {
		this.maxN = maxN;
	}


	public int getGroups() {
		return groups;
	}


	public void setGroups(int groups) {
		this.groups = groups;
	}


	public int getMaxGroupSize() {
		return maxGroupSize;
	}


	public void setMaxGroupSize(int maxGroupSize) {
		this.maxGroupSize = maxGroupSize;
	}


	public int getMinGroupSize() {
		return minGroupSize;
	}


	public void setMinGroupSize(int minGroupSize) {
		this.minGroupSize = minGroupSize;
	}


	public int getGroupRadius() {
		return groupRadius;
	}


	public void setGroupRadius(int groupRadius) {
		this.groupRadius = groupRadius;
	}


	public double getGlobalGroupDispersion() {
		return globalGroupDispersion;
	}


	public void setGlobalGroupDispersion(double globalGroupDispersion) {
		this.globalGroupDispersion = globalGroupDispersion;
	}


	public double getMutationRate() {
		return mutationRate;
	}


	public void setMutationRate(double mutationRate) {
		this.mutationRate = mutationRate;
	}


	public double getIbiTau() {
		return ibiTau;
	}


	public void setIbiTau(double ibiTau) {
		this.ibiTau = ibiTau;
	}


	public double getBaseResourceEndowment() {
		return baseResourceEndowment;
	}


	public void setBaseResourceEndowment(double baseResourceEndowment) {
		this.baseResourceEndowment = baseResourceEndowment;
	}


	public double getPercentBaseResourceEndowment() {
		return percentBaseResourceEndowment;
	}


	public void setPercentBaseResourceEndowment(double percentBaseResourceEndowment) {
		this.percentBaseResourceEndowment = percentBaseResourceEndowment;
	}


	public double getAge_ibiTau_multiplier() {
		return age_ibiTau_multiplier;
	}


	public void setAge_ibiTau_multiplier(double age_ibiTau_multiplier) {
		this.age_ibiTau_multiplier = age_ibiTau_multiplier;
	}


	public boolean isCarryOver() {
		return carryOver;
	}


	public void setCarryOver(boolean carryOver) {
		this.carryOver = carryOver;
	}


	public double getSdAge() {
		return sdAge;
	}


	public void setSdAge(double sdAge) {
		this.sdAge = sdAge;
	}


	public double getResourceEndowmentSD() {
		return resourceEndowmentSD;
	}


	public void setResourceEndowmentSD(double resourceEndowmentSD) {
		this.resourceEndowmentSD = resourceEndowmentSD;
	}


	public double getResourceEndowmentSuccessRate() {
		return resourceEndowmentSuccessRate;
	}


	public void setResourceEndowmentSuccessRate(double resourceEndowmentSuccessRate) {
		this.resourceEndowmentSuccessRate = resourceEndowmentSuccessRate;
	}


	public int getRecipients() {
		return recipients;
	}


	public void setRecipients(int recipients) {
		this.recipients = recipients;
	}


	public int getProposers() {
		return proposers;
	}


	public void setProposers(int proposers) {
		this.proposers = proposers;
	}


	public boolean isSex() {
		return sex;
	}


	public void setSex(boolean sex) {
		this.sex = sex;
	}


	public boolean isUgOfferZero() {
		return ugOfferZero;
	}


	public void setUgOfferZero(boolean ugOfferZero) {
		this.ugOfferZero = ugOfferZero;
	}


	public double getDispersalRate() {
		return dispersalRate;
	}


	public void setDispersalRate(double dispersalRate) {
		this.dispersalRate = dispersalRate;
	}


	public int getDispersalRadius() {
		return dispersalRadius;
	}


	public void setDispersalRadius(int dispersalRadius) {
		this.dispersalRadius = dispersalRadius;
	}


	public int getSamplingInterFactor() {
		return samplingInterFactor;
	}


	public void setSamplingInterFactor(int samplingInterFactor) {
		this.samplingInterFactor = samplingInterFactor;
	}


	public int getGenerations() {
		return generations;
	}


	public void setGenerations(int generations) {
		this.generations = generations;
	}


	public int getBurinGenerations() {
		return burinGenerations;
	}


	public void setBurinGenerations(int burinGenerations) {
		this.burinGenerations = burinGenerations;
	}
	/*
	 * Getter and Setter Methods end
	 */




	
	/*
	 * Environment constructor methods
	 */
	
	public int getRejectionSampleSize() {
		return rejectionSampleSize;
	}


	public void setRejectionSampleSize(int rejectionSampleSize) {
		this.rejectionSampleSize = rejectionSampleSize;
	}


	public boolean isIbi() {
		return ibi;
	}


	public void setIbi(boolean ibi) {
		this.ibi = ibi;
	}


	public Environment(long seed, Class observer) {
		super(seed, observer);

	}


	public Environment(long seed, Class observer, String runTimeFileName) {
		super(seed, observer, runTimeFileName);

	}


	/**
	 * Makes the initial groups for a simulation and prepares for parameter
	 * sweeps if any are to be run
	 */
	public void makeGroups() {

		autoCalculateGame();
		
		calulateOfferList();//creates the list of possible offers and equitability index
		int m = n/groups; //the initial number of agents in each group
		for(int i=0;i<groups;i++) {
			int x = random.nextInt(gridWidth);
			int y = random.nextInt(gridHeight);
			Bag g = new Bag(m);
			for(int j=0;j<m;j++) {
				double offer,accept;
				if(ugOfferZero) {
					offer = 0.0;
					accept = 0.0;
				}
				else {
					offer = offerArray[random.nextInt(offerArray.length)];
					accept = offerArray[random.nextInt(offerArray.length)];
				}

				Agent a;
				a = new Agent(this,offer,accept, true, 0.0, x, y);//start with the p = 0
				a.event = schedule.scheduleRepeating(1,0,a);//schedule the agent
				g.add(a);//add agent to a Bag
			}
			Group group = new Group(this,x,y,g);//create a new group from the bag of agents
			group.event = schedule.scheduleRepeating(1.0, 1,group,scheduleTimeInterval);//schdule after agents
			sparseSpace.setObjectLocation(group, x, y);//place that group randomly into space
		}
	}

	/**
	 * automatically calculated key parameters of the model
	 */
	public void autoCalculateGame() {
		double n = recipients+proposers;
		resourceEndowmentSuccessRate = (double)proposers/n;
		resourceEndowment = (baseResourceEndowment*percentBaseResourceEndowment) * n/(double)proposers;//may be reduced by a percentatge
		this.reSD = resourceEndowment * this.resourceEndowmentSD;
		io = (double)this.ibiTau * this.baseResourceEndowment;
		this.averageAge = this.age_ibiTau_multiplier * this.ibiTau;
		uniform = new Uniform(resourceEndowment-reSD, resourceEndowment+reSD, random);
		tnormal = new TruncNormal(random,resourceEndowment,reSD,0.0,resourceEndowment*2.0);
		System.out.println("resoucesEndowment = "+ resourceEndowment + " "+"resourceEndowmentSD = "+reSD +" "+"ibiTau = "+ibiTau+" "+"io = "+io+" "+"averageAge = "+averageAge);
	}


	public void autoCalculationSimulationControl() {
		super.autoCalculationSimulationControl();
		autoCalculateGame();
		this.simLength = (long)this.generations * (long)this.averageAge + 1;
		this.burnIn = this.burinGenerations * (int)this.averageAge;
		this.dataSamplingInterval = this.samplingInterFactor * (int)this.averageAge;
		System.out.println("simLength = "+simLength +" "+"burnIn = "+burnIn+" "+"dataSamplingInterval = "+dataSamplingInterval);
	}

	/**
	 * Returns an offer array 
	 * @param index
	 * @return
	 */
	public void calulateOfferList() {
		double[] array = new double[]{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0};
		if(n_intervals % 2 == 0) {
			switch(this.n_intervals) {
			case 4:array = new double[]{0.0,0.25,0.5,0.75,1.0};
			break;
			case 6:array = new double[]{0.0,0.166,0.3333333,0.5,0.666666667,0.833333333,1.0};
			break;
			case 8:array = new double[]{0.0,0.125,0.25,0.375,0.5,0.625,0.75,0.875,1.0};
			break;
			case 10:array = new double[]{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0};
			break;
			case 12: array = new double[]{0.0,0.083333333,0.166666667,0.25,0.333333333,0.416666667,0.5,0.583333333,0.666666667,0.75,0.833333333,0.916666667,1.0};
			break;
			default:
				array = new double[]{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0};
			}
		}
		else
		{
			System.out.println("n_intervals is not even, n_intervals = 10 by default is used.");
		}
		offerArray = array;
		offerIntervals = offerArray.length;
	}


	/**
	 * Extention of start method in SimState.  Sets up simulation.
	 */
	public void start() {
		super.start();//start method in SimState sweep
		spaces = Spaces.SPARSE;//set the space

		make2DSpace(spaces,gridWidth,gridHeight);//make the space
		makeGroups();//make the groups

		//experimenter stuff
		if(observer != null) {
			observer.initialize(sparseSpace, spaces);//initialize the experimenter
			(experimenter = (Experimenter)observer).initialize(this, offerArray);
		}

	}
}
